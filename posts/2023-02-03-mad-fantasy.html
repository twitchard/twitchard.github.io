<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@twitchard" />
        <meta name="twitter:title" content="Can the one-size-fits-all web be overthrown?" />
        <meta name="twitter:description" content="UX as specification" />
        <meta name="description" property="og:description" content="UX as specification" />
        <meta name="author" property="og:author" content="Richard Marmorstein" />
        
        <title>Can the one-size-fits-all web be overthrown? - Richard Marmorstein</title>
        <link rel="alternate" type="application/atom+xml" href="../atom.xml">
        <link rel="stylesheet" href="../css/default.css" />

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

        <link href="https://fonts.googleapis.com/css?family=Finger Paint" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans&display=swap" rel="stylesheet">
        <!-- Used for drop cap for the first character of blog posts-->
        <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet"> 
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet"> 
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-DPC615L5M6"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
    
      gtag('config', 'G-DPC615L5M6');
    </script>
    </head>
    <body>
        <main role="main">
            <article>
    <section class="header">
      <h1>Can the one-size-fits-all web be overthrown?</h1>
      <h3>by Richard Marmorstein - February  3, 2023</h3>
      <h4><a href="../">← Home</a></h4>
    </section>
    <section class="prose">
        <h2 id="the-rotting-of-the-web">The rotting of the web</h2>
<p>Something is wrong with the web. It is lifeless, soulless.</p>
<p>I recently read a book from 1996: <a href="Surfing%20the%20Internet%20with%20Netscape%20Navigator%202">https://archive.org/details/surfinginternetw00taub/page/388/mode/2up</a>. The web was alive then, I think. You can hear it in the names of things. It was Netscape “Navigator”. An early search engine was “Magellan”. There was a sense of exploration, discovery! People were excited to find, and to create.</p>
<p>On todays web, we scroll feeds of viral content. We create nothing. Every web app looks the same, less a color scheme and the number of columns in the layout. Go to LinkedIn, Goodreads, Amazon, Google docs, and weep at the homogeny.</p>
<p>There are reasons. Users demand familiar interfaces. If your web site doesn’t work like the others, users will get frustrated. Back in the early days, the web was hobbyists and eccentrics, so heterogeneity was all well and good. These days, people are using the web for serious business. So sterility must rule.</p>
<p>But I think this is only true because users don’t have any power. LinkedIn.com has the interface it has. It works the way it works. It looks the way it looks. And the user can customize nothing. They can’t change the colors, they can’t change the layout, they can’t hide the bits they don’t care about, they can’t pin the bits they do to the top. Of course they can’t. That experience would take way too much effort to build. And no user is asking for it. Users are quite accustomed to this world where they have absolutely no control over the places they go and the tools they use. Developers have all the control, and we have all the responsibility.</p>
<p>Do you have forty minutes? Can you listen to audio? I strongly recommend a talk, <a href="https://thestrangeloop.com/2021/authorship-environments-in-search-of-the-personal-in-personal-computing.html"><em>Authorship Environments: In search of the “personal” in personal computing</em></a> by <a href="https://twitter.com/ecgade">Eric Gade</a>. More interesting than anything I have to say. A takeaway: non-programmers had more power in the early days.</p>
<p>An example: early Apple computers had a precursor to the web called “HyperCard”. HyperCard was a visual environment for building apps that anybody could inspect, make copies of, and easily modify and redistribute. Its language “HyperTalk” was very accessible and meant to be friendly to non-programmers.</p>
<p>The web in the early days was a lot more empowering to users, too. “View source” actually worked and gave you something legible you could copy&amp;paste in order to borrow something that you encountered. Early browsers let you customize colors. Internet Explorer even let users define an entire stylesheet that would be applied as part of the CSS “cascade”. And users could customize quite a bit about their web experience via choosing a different web browser, because web browsers back then weren’t all just clones of each other; i.e. a selling point for Netscape Navigator over its precursors was the “attractive” way that it displayed web pages.</p>
<h2 id="what-happened">What happened?</h2>
<p>I don’t think anybody set out to <em>deliberately</em> take away power from users. Nobody really wanted to break “view source”. Web apps just got too big and complicated. HTML alone stopped being a good way to describe them. Javascript got huge and we started needing to minify things in order to save bytes.</p>
<p>Nobody really wanted to take away user-defined CSS stylesheets. They were just, never really a thing. No users used them, and so no developers took them into account and designed a web app that would play nicely with them, and so no users used them, and so no developers considered them.</p>
<p>Nobody really wanted to take away browser choice either. Developers just had very specific interfaces they wanted to build, and got frustrated working around browser quirks, so there was enormous pressure for all the browsers to become clones of each other.</p>
<p>Maybe there are underlying political/economic reasons behind the disempowerment of users, but from my perspective, I think this was all just a sad accident.</p>
<p>So, how do we reverse it? Can we resurrect the age of personal computing?</p>
<p>Perhaps we can. If we lost it by accident, perhaps we can also regain it by accident, while focusing on another problem entirely.</p>
<h2 id="multiple-targets">Multiple Targets</h2>
<p>You can’t just build a web app, these days. If you really want to be cool, you also build Android/ios apps. If you want to be cooler still, you build apps for Smart TVs, voice assistants, game consoles. Maybe you even build a CLI and a public REST API. Maybe you build a special “lite” version of your app to serve over slow connections, or when experiences are degraded. Maybe you build a version of your web app optimized for screen readers.</p>
<p>Fine, let’s be real. Hardly anybody is that cool. Most shops just build a one-size-fits-all web app and call it a day. Doing all the rest is just too much work!</p>
<p>But I think (hope?) that this will change. It’s overhyped, but the “internet of things” is slowly arriving. So is “augmented reality”. Maybe not soon, but the day is not that far off when people will put their phones and their laptops down, and begin expecting to be able to interact with computers in the environment around them. On that day, it’s not going to be enough to ship a one-size-fits-all web app and be done.</p>
<p>In preparation for that day, we’re going to have to start thinking more abstractly. We’re going to have to start building apps at a higher level. More specifically, I think we’re going to have to <em>stop building UIs</em> and start <em>specifying UXs</em>.</p>
<h2 id="some-history">Some history</h2>
<p>Forty, fifty years ago – there wasn’t such a hard distinction between “programmers” and “users”. I saw a great talk that mentioned this: If you have forty minutes and can listen to audio, stop reading this blog post and go watch the Youtube video.</p>
<p>Gade mentions “Hypercard”, a sort of precursor to web applications. It came for free on Mac computers, and it allowed you to build apps anybody could inspect, make copies of, and easily modify and redistribute.</p>
<p>He also mentions how, Smalltalk was a programming environment design and tested originally <em>on children</em>. It was a “programming environment”, but in those days there was no difference between a programming environment and a computing environment, they were one and the same.</p>
<p>But this is not the world we live in anymore. In our age, there is a stark distinction between programmers and users. As time goes by, software is becoming <em>less</em> personal. Users experience <em>less and less</em> control over how they experience software.</p>
<p>In the early days of the web, you could visit a web page, “view source”, and what you saw was ia representation of what you could see in your browser, intelligible to the layman, even. You could copy + paste it into your own website.</p>
<p>Browsers, back then, were properly “user agents”. The web pages of old were fairly abstract descriptions of document content, and web browsers had a lot of latitude in terms of how the content would be displayed. It had to be this way – the systems running web browsers were so vastly different from each other. The first web browser “WorldWideWeb” was written on Berners-Lee’s graphical NeXT computer. The second web browser was “Line Mode Browser”, written to run on non-graphical teletype machines. They displayed contents according to the user’s wishes and their system’s constraints.</p>
<p>These days, users have very choice in terms of web browser. You have two choices: chrome or webkit, and those aren’t even very different. Each browser implements essentially the same features. The user can customize very little about the experience of browsing. You can select a font size, maybe, and “dark mode”, perhaps, but the browser can permit customization of very little else. Browsers are expected not to deviate from incredibly specific web standards, because every single web app is written to be incredibly picky about every last detail, down to the pixel.</p>
<p>When I started learning about the web, there was this popular sentiment about how good it was for your HTML, CSS, and Javascript to exist separately so that content could be defined differently from presentation could be defined differently from behavior. There was (is still) this website <a href="http://www.csszengarden.com/">“CSS Zen Garden”</a> to demonstrate the power of this idea. It featured a single article with fixed HTML, but you can choose from dozens of CSS stylesheets in order to completely change the layout and appearance of the article.</p>
<p>It used to be that browsers supported “user-defined CSS”. Wanted to change the default font color to pink? Or for visited links to be strikethrough? You could! And your own defined styles would be applied as part of the “cascade”.</p>
<p>Now, the separation of HTML, CSS, and Javascript has fallen out of favor. The orthodoxy now, with React and Tailwind and all, is that the most practical way to build web apps is to define content, behavior, and presentation together. CSS Zen Garden was a lie. Sure, you could build one page and a hundred different ways to style it. But you couldn’t take those styles and apply them to another page unless its content had exactly the same structure. User-defined CSS has also gone the way of the dodo. Again, because every web app is written to be incredibly picky about every detail, down to the pixel.</p>
<h2 id="why-did-all-this-happen">Why did all this happen?</h2>
<p>Perhaps there are policical, economic reasons underlying all this, but superficially it seems to me that this is all mostly an accident.</p>
<p>Nobody really wanted to break “view source”. Web apps just got too big and complicated. HTML alone stopped being a good way to describe them. Javascript got huge and we started needing to minify things in order to save bytes.</p>
<p>Nobody really wanted to take away user-defined CSS stylesheets. They were just, never really a thing. No users used them, and so no developers took them into account and designed a web app that would play nicely with them, and so no users used them, and so no developers considered them.</p>
<p>Nobody really wanted to take away browser choice either. Developers just had very specific interfaces they wanted to build, and got frustrated working around browser quirks, so there was enormous pressure for all the browsers to become clones of each other.</p>
<p>This was all just a sad accident. Nobody’s really put out about this. Customizing how</p>
<p>How do we fix it? I propose we fix it by accident, while trying to solve a different problem entirely.</p>
<h2 id="multiple-targets-1">Multiple Targets</h2>
<p>You can’t just build a web app, these days. If you really want to be cool, you also build an Android app, and an ios app. If you want to be cooler still, you build an app for Smart TVs, you build a integrations with Alexa, Google Assistant, and all the other voice assistants out there. Maybe you even build a CLI and a public REST API. But why stop there? Maybe you build a special “lite” version of your app to serve over slow connections, or when experiences are degraded. Maybe you build a version of your web app optimized for screen readers.</p>
<p>Fine, let’s be real. Hardly anybody is that cool. Most shops just build a one-size-fits-all web app and call it a day. Doing all the rest is just too much work!</p>
<p>But I think (hope?) that this will change. It’s overhyped, but the “internet of things” is slowly arriving. So is “augmented reality”. Maybe not soon, but the day is not that far off when people will put their phones and their laptops down, and begin expecting to be able to interact with computers in the environment around them. On that day, it’s not going to be enough to ship a one-size-fits-all web app and be done.</p>
<p>In preparation for that day, we’re going to have to start thinking more abstractly. We’re going to have to start building apps at a higher level. More specifically, I think we’re going to have to <em>stop building UIs</em> and start <em>specifying UXs</em>.</p>
<h2 id="ux-as-specification-ui-as-implementation">UX as specification, UI as implementation</h2>
<p>This is my mad fantasy: a programming language that allows you to specify a UX “interface”, where a UI is an “implementation” of that interface.</p>
<p>For example, a UX specification might describe</p>
<blockquote>
<p>the user can submit their street address, zip code, city, and state to indicate where they want their order to be sent</p>
</blockquote>
<p>and UIs that “implement” this UX might be
* an HTML form with text input labeled “street address”, “zip code” etc. and a submit button that sends some JSON to a <code>POST /shipping_info</code> API; or
* a series of voice prompts “what is your zip code?”, “what is your street address”?, “you gave your address as … is this correct?” on a platform like Alexa.</p>
<p>In my fantasy, you don’t merely <em>check</em> that a UI satisfies a UX specification (like <a href="https://docs.quickstrom.io/en/latest/">quickstrom</a> can) – you can <em>generate</em> a working UI from a UX specification. That is, specify your UX correctly and solve the “too many targets” problem – you can generate a working web app, mobile app, voice assistant experience, CLI, “lite” web app, accesibility-optimized web app, etc.</p>
<p>I want developers to stop being picky about every last pixel of their UI; at least, I want them to suspend their pickiness long enough to write down, in a machine-interpretable way, the <em>core</em> of what it means to have a working app that lets users accomplish the goal that the app is intendned to help them accomplish – without reference to particular widgets, stylings, etc. Then, separately, if they want to be picky again and create a perfectly polished experience, laid out a specific way, using specific widgets, etc. they can do this for a particular target <em>on top</em> of their “core” UX specification. In contrast to how web development happens today, where nobody actually writes down what it means to have a working app, or what goals the user is supposed to be able to achieve. They just program a description of some widgets, and if you’re curious what goals the author of the UI intended the user to be able to accomplish, you have to reverse engineer the intent from what widgets exist.</p>
<p>As part of this, we would bring back the “CSS Zen Garden” idea of separating the the UX “bones” of an app from its presentation details. True, the separation of HTML, CSS, and Javascript is a failed project. They are hopelessly coupled to each other, though they pretended not to be for years in the aughts. But I think HTML/CSS/Javascript is just a failed attempt at this idea. That doesn’t mean the idea is worth abandoning.</p>
<h2 id="this-is-all-very-handwavey-richard.-this-is-a-fun-fantasy-sure-but-i-have-a-better-fantasy-how-about-web-apps-just-magically-write-themselves-top-that-one-or-do-you-actually-have-some-substance-to-offer">This is all very handwavey, Richard. This is a fun fantasy, sure, but I have a better fantasy: how about web apps just magically write themselves? Top that one! Or do you actually have some substance to offer…</h2>
<p>Wow, harsh. It’s true, this is all very handwavey. But let me try to wave my hands a little more convincingly. Let me try and describe what I hope would be a promising direction for trying to implement something like this.</p>
<p>“Broad goals that can ‘decompose’ into narrower user goals.
UI components and rules for:w</p>
<p>That’s right. I’m hardly the first person who wants to generate multiple apps from a single specification. Isn’t that what React Native is about? There’s also a long tradition of people who wanted to like, generate implementations from high-level UML specifications. Do I have anything to offer besides</p>
<p>First, <strong>specifying UX is harder than specifying UI</strong>. Specifying UX, as I picture, involves <em>psychology</em>. You model what’s going on in the user’s mind: their initial goals, their understanding of the application’s capabilities, and how these can evolve as they interact with the application.</p>
<p>Here’s an example. Suppose I want to purchase a gift for my wife.</p>
<ol type="1">
<li>I start with a broad goal: <strong>purchase a suitable gift</strong> and a vague notion that amazon.com can be used for shopping.</li>
<li>I go to amazon.com, see a list of categories, and form a narrower goal: <strong>identify a promising category</strong>.</li>
<li>I notice a list of categories, form a new goal to find and browse a promising category, identify “coffee” as a promising category, and form a narrower goal: <strong>browse the <em>coffee</em> category</strong>.</li>
<li>I click coffee, am presented with summary panes of items, and form a new goal: <strong>browse only coffee accessories, not coffee beans</strong>.</li>
<li>I notice a search bar at the top, identify “romantic coffee accessories” as a promising search phrase, submit, and am greeted with a new list of promising items.</li>
<li>I notice filters on the side for shipping and price, and develop a new goal: <strong>browse coffee accessories that match my price and shipping criteria</strong>.</li>
<li>I specify “$20-$50” and “arrives before Valentine’s day” and begin to browse.</li>
<li>I find a french press with hearts on it and a heart-shaped coffee scoop. It is everything I ever wanted. I form a new goal: <strong>purchase this amazing french press</strong>.</li>
<li>I notice a “buy now” button for the coffee mug warmer. I click it and it takes me to the checkout page. I form a new goal: <strong>provide Amazon with my payment and shipping information</strong>.</li>
<li>… you get the picture</li>
</ol>
<p>I guess what I’m trying</p>
<h3 id="section"></h3>
<p>I think there are two
In order for this vision to succeed:</p>
<ul>
<li><strong>Describing a UX needs to be as easy as describing a UI</strong></li>
<li>**Customizing a generated UI must be as easy as customizing a directly-implemented UI.
The generators need to support</li>
</ul>
<p>This is important. The “Internet of Things” was overhyped, but it is coming. We’re moving away from just the desktop computer and smartphones. We’re talking to the TV. Alexa’s in our fridge: Siri is in our ears. Voice is an important medium now.</p>
<p>In dull reality, you can’t build an application by writing down the UX. What you write down is a description of a UI. The UX is implicit. If you need to reason about the UX, you must infer it from the implemented UI. If the UI renders a button labeled “generate report”, for example, you can infer that users expect to be able to generate reports. Dig deeper into the implementation and you might also discover that this button relates also a separate UX – perhaps the users also expect the ability to inspect an “activity log” that includes the times and ip addresses corresponding to when report generation was triggered.</p>
<p>But what if we flipped it? What if UX was the thing you wrote down, and the computer was able to infer/generate an appropriate UI implementation.</p>
<p>Mad? Perhaps. But humor me. Imagine.</p>
<p>Given high quality “UI generators”, your application could be correct by construction. It would be tractable to quickly prototype multiple uis from a single specification.</p>
<p>This is important. It’s slow, but the “internet of things” is expanding. We’re moving away from just the desktop computer and smartphones. We’re talking to the TV. Alexa’s in our fridge: Siri is in our ears. Voice is an important medium now.</p>
<p>Mad? Oh yes.
A sketch</p>
<p>So far, this is ranting and handwaving. Can it be built? I am hopeful.</p>
<p>Here I will sketch out in more detail a possible approach to this.</p>
<p>The key, I think, is a language for describing UX abstractly.</p>
<p>Describe user goals abstractly.
Describe the application and its capabilities abstractly.
Model the users conceptual model</p>
<p>A description of the UX
Rules forq</p>
<p>The “user interface” involves displaying widgets, attaching behavior to widgets, and styling widgets and content.</p>
<p>The “user experience” is an abstract model of how the user can interact with the application in order to achieve their goal.</p>
<p>For example, “an HTML form pointed to POST /shipping_info with text input with labels “zip code”, “street address”, “street address 2”, “city” and “state” and a submit button” would be a description of a user interface.</p>
<p>“The user can submit their zip code, street address, street address 2, city, and state” would be a description of the user experience.</p>
<p>The user experience, in this conception, is an abstract specification. The user interface “implements” the user experience, so to speak</p>
<p>A “user experience” is a
A “user experience”
A button can resolve.</p>
<p>Add a label “submit” to a button, and place it near a credit card info form,</p>
<p>A user interface</p>
    <hr />

    <div class="callToAction">
    <p>
    
      Thanks for reading!
    
    To read more by me, you can subscribe to the <a href="../atom.xml">Atom feed</a> or follow my <a href="https://twitter.com/twitchard">Twitter</a>.</p>
    
    
    <h4><a href="../">Home</a></h4>
    </div>
    </section>
</article>

        </main>

        <footer>
          <div class="leftfootleftfootleftfoot">
            Nothing I write represents the opinion of those foolish enough to employ me.
          </div>
          <div class="rightfeetatthemorningfeetatnight">
            Site shamefully generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
          </div>
        </footer>
    </body>
</html>
